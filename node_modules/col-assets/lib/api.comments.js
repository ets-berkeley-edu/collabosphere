/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var Joi = require('joi');

var CollabosphereUtil = require('col-core/lib/util');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-assets');
var UserConstants = require('col-users/lib/constants');

var AssetsAPI = require('col-assets');

/**
 * Get a comment.
 * Note that this is a private method that doesn't do any validation
 *
 * @param  {Number}         id                              The id of the comment to retrieve
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.comment                The created comment
 * @param  {User}           callback.comment.user           The user that created the comment
 * @api private
 */
var getComment = function(id, callback) {
  var options = {
    'where': {
      'id': id
    },
    'include': [{
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    }]
  };
  DB.Comment.find(options).complete(function(err, comment) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to retrieve the created comment');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, comment);
  });
};

/**
 * Create a new comment on an asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         assetId                         The id of the asset to which the comment is added
 * @param  {String}         body                            The body of the comment
 * @param  {Number}         [parent]                        The id of the comment to which the comment is a reply
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.comment                The created comment
 * @param  {User}           callback.comment.user           The user that created the comment
 */
var createComment = module.exports.createComment = function(ctx, assetId, body, parent, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'assetId': Joi.number().required(),
    'body': Joi.string().required(),
    'parent': Joi.number().optional()
  });

  var validationResult = Joi.validate({
    'assetId': assetId,
    'body': body,
    'parent': parent
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the asset to which the comment is being added
  AssetsAPI.assets.getAsset(ctx, assetId, false, function(err, asset) {
    if (err) {
      return callback(err);
    }

    // Check that the comment to which this comment is a reply exists
    if (parent) {
      // Ensure the parent id is a number
      parent = CollabosphereUtil.getNumberParam(parent);
      var parentComment = _.findWhere(asset.toJSON().comments, {'id': parent});
      if (!parentComment) {
        log.error({'err': err, 'parent': parent}, 'Failed to find the comment to which a reply is being made');
        return callback({'code': 400, 'msg': 'Failed to find the comment to which a reply is being made'});
      }
    }

    // Create the link asset in the database
    var comment = {
      'asset_id': assetId,
      'user_id': ctx.user.id,
      'parent_id': parent,
      'body': body
    };

    DB.Comment.create(comment).complete(function(err, comment) {
      if (err) {
        log.error({'err': err}, 'Failed to create a new comment');
        return callback({'code': 500, 'msg': err.message});
      }

      // Increase the comment count
      asset.increment('comment_count').complete(function(err, asset) {

        // Retrieve the created comment, including the associated user
        getComment(comment.id, callback);
      });
    });
  });
};

/**
 * Edit a comment on an asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         assetId                         The id of the asset to which the comment belongs
 * @param  {Number}         id                              The id of the comment that is being edited
 * @param  {String}         body                            The updated comment body
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.comment                The updated comment
 * @param  {User}           callback.comment.user           The user that created the comment
 */
var editComment = module.exports.editComment = function(ctx, assetId, id, body, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'assetId': Joi.number().required(),
    'id': Joi.number().required(),
    'body': Joi.string().required()
  });

  var validationResult = Joi.validate({
    'assetId': assetId,
    'id': id,
    'body': body
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the comment that is being edited
  var options = {
    'where': {
      'id': id,
      'asset_id': assetId
    },
    'include': [DB.Asset]
  };

  DB.Comment.find(options).complete(function(err, comment) {
    if (err) {
      log.error({'err': err, 'id': id, 'assetId': assetId}, 'Failed to retrieve the comment to update');
      return callback({'code': 500, 'msg': err.message});
    } else if (!comment) {
      log.debug({'err': err, 'id': id, 'assetId': assetId}, 'The comment that is being edited could not be found');
      return callback({'code': 404, 'msg': 'The comment that is being edited could not be found'});
    }

    // Verify that the user is allowed to edit the comment. A user is
    // only able to edit a comment when the user manages the course or
    // the comment is their own
    if ((!ctx.user.is_admin || comment.asset.course_id !== ctx.course.id) && comment.user_id !== ctx.user.id) {
      log.error({'assetId': assetId, 'id': id}, 'Unauthorized to edit the comment');
      return callback({'code': 401, 'msg': 'Unauthorized to edit the comment'});
    }

    // Update the comment
    var update = {
      'body': body
    };

    comment.updateAttributes(update).complete(function(err, comment) {
      if (err) {
        log().error({'err': err}, 'Failed to update a comment');
        return callback({'code': 500, 'msg': err.message});
      }

      // Retrieve the updated comment, including the associated user
      getComment(comment.id, callback);
    });
  });
};
