/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var fs = require('fs');
var Joi = require('joi');
var mime = require('mime');
var path = require('path');
var request = require('request');
var util = require('util');

var ActivitiesAPI = require('col-activities');
var CanvasAPI = require('col-canvas');
var CategoriesAPI = require('col-categories');
var CollabosphereConstants = require('col-core/lib/constants');
var CollabosphereUtil = require('col-core/lib/util');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-assets');
var UserConstants = require('col-users/lib/constants');

/**
 * Get an asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         id                              The id of the asset
 * @param  {Boolean}        [incrementViews]                Whether the total number of views for the asset should be incremented by 1
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Asset}          callback.asset                  The requested asset
 */
var getAsset = module.exports.getAsset = function(ctx, id, incrementViews, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'id': Joi.number().required(),
    'incrementViews': Joi.boolean().optional()
  });

  var validationResult = Joi.validate({
    'id': id,
    'incrementViews': incrementViews
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the asset from the DB
  var options = {
    'where': {
      'id': id,
      'course_id': ctx.course.id
    },
    'include': [
      {
        'model': DB.Activity,
        'attributes': ['type'],
        'required': false,
        'where': {
          'course_id': ctx.course.id,
          'user_id': ctx.user.id,
          'type': ['like', 'dislike'],
          'asset_id': id,
          'object_type': 'asset'
        }
      },
      {
        'model': DB.User,
        'attributes': UserConstants.BASIC_USER_FIELDS
      }, {
        'model': DB.Category
      }, {
        'model': DB.Comment,
        'include': [{
          'model': DB.User,
          'attributes': UserConstants.BASIC_USER_FIELDS
        }]
      }
    ]
  };
  DB.Asset.find(options).complete(function(err, asset) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to get an asset');
      return callback({'code': 500, 'msg': err.message});
    } else if (!asset) {
      log.debug({'err': err, 'id': id}, 'An asset with the specified id could not be found');
      return callback({'code': 404, 'msg': 'An asset with the specified id could not be found'});
    }

    // Increment the number of views for the asset if specified
    if (incrementViews) {
      asset.increment('views').complete(function(err, asset) {
        if (err) {
          log.error({'err': err, 'id': id}, 'Failed to increase the views on an asset');
          return callback({'code': 500, 'msg': err.message});
        }

        return callback(null, asset);
      });
    } else {
      return callback(null, asset);
    }
  });
};

/**
 * Get the assets for the current course
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         [limit]                         The maximum number of results to retrieve. Defaults to 10
 * @param  {Number}         [offset]                        The number to start paging from. Defaults to 0
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object}         callback.assets                 The retrieved assets
 * @param  {Number}         callback.assets.total           The total number of assets in the current course
 * @param  {Asset[]}        callback.assets.results         The paged assets in the current course
 */
var getAssets = module.exports.getAssets = function(ctx, limit, offset, callback) {
  // Default some parameters
  limit = CollabosphereUtil.getNumberParam(limit, 10, 1, 25);
  offset = CollabosphereUtil.getNumberParam(offset, 0, 0);

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'limit': Joi.number().required(),
    'offset': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'limit': limit,
    'offset': offset
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the assets from the DB
  var options = {
    'where': {
      'course_id': ctx.course.id
    },
    'order': [['created_at', 'DESC']],
    'limit': limit,
    'offset': offset,
    'include': [
      {
        'model': DB.Activity,
        'attributes': ['type'],
        'required': false,
        'where': {
          'course_id': ctx.course.id,
          'user_id': ctx.user.id,
          'type': ['like', 'dislike'],
          'object_type': 'asset'
        }
      },
      {
        'model': DB.User,
        'attributes': UserConstants.BASIC_USER_FIELDS
      }
    ]
  };
  DB.Asset.findAndCountAll(options).complete(function(err, result) {
    if (err) {
      log.error({'err': err, 'course': ctx.course}, 'Failed to get the assets in the current course');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, {
      'total': result.count,
      'results': result.rows
    });
  });
};

/**
 * Create a new link asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {String}         title                           The title of the link
 * @param  {String}         url                             The url of the link
 * @param  {Object}         [opts]                          A set of optional parameters
 * @param  {Number[]}       [opts.categories]               The ids of the categories to which the link should be associated
 * @param  {String}         [opts.description]              The description of the link
 * @param  {String}         [opts.source]                   The source of the link
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Asset}          callback.asset                  The created link asset
 */
var createLink = module.exports.createLink = function(ctx, title, url, opts, callback) {
  // Default the title to the provided url
  title = title || url;

  // Default the optional values
  opts = opts || {};
  opts.categories = opts.categories || [];

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'title': Joi.string().required(),
    'url': Joi.string().uri().required(),
    'opts': Joi.object().keys({
      'categories': Joi.array().unique().items(Joi.number()).optional(),
      'description': Joi.string().allow('').optional(),
      'source': Joi.string().uri().optional()
    })
  });

  var validationResult = Joi.validate({
    'title': title,
    'url': url,
    'opts': opts
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the link asset in the DB
  var asset = {
    'course_id': ctx.course.id,
    'user_id': ctx.user.id,
    'type': 'link',
    'title': title,
    'url': url,
    'description': opts.description,
    'source': opts.source
  };

  return createAsset(ctx, asset, opts.categories, callback);
};

/**
 * Create a new file asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {String}         title                           The title of the file
 * @param  {String}         file                            The file to create
 * @param  {Object}         [opts]                          A set of optional parameters
 * @param  {Number[]}       [opts.categories]               The ids of the categories to which the file should be associated
 * @param  {String}         [opts.description]              The description of the file
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Asset}          callback.asset                  The created link asset
 */
var createFile = module.exports.createFile = function(ctx, title, file, opts, callback) {
  file = file || {};
  // Default the title to the provided filename
  title = title || file.filename;

  // Default the optional values
  opts = opts || {};
  opts.categories = opts.categories || [];

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'title': Joi.string().required(),
    'file': Joi.object().required().keys({
      'field': Joi.any().valid('file'),
      'encoding': Joi.string().required(),
      'mimetype': Joi.string().required(),
      'truncated': Joi.boolean().valid(false),
      'uuid': Joi.string().guid().required(),
      'file': Joi.string().required(),
      'filename': Joi.string().required()
    }),
    'opts': Joi.object().keys({
      'categories': Joi.array().unique().items(Joi.number()).optional(),
      'description': Joi.string().allow('').optional(),
      'source': Joi.string().uri().optional()
    })
  });

  var validationResult = Joi.validate({
    'title': title,
    'file': file,
    'opts': opts
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // For security reasons, the canvas object on the course API only contains the `use_https` and
  // `canvas_api_domain` attributes. By reloading the instance all other attributes such as the
  // `canvas_api_key` will be retrieved
  ctx.course.canvas.reload().complete(function(err) {
    if (err) {
      return callback(err);
    }

    // Upload the file to Canvas
    uploadFileToCanvas(ctx, file.file, function(err, canvasItem) {
      if (err) {
        return callback(err);
      }

      // Create the file asset in the DB
      var asset = {
        'course_id': ctx.course.id,
        'user_id': ctx.user.id,
        'type': 'file',
        'title': title,
        'download_url': canvasItem.url,
        'mime': canvasItem['content-type'],
        'description': opts.description,
        'source': opts.source
      };
      return createAsset(ctx, asset, opts.categories, callback);
    });
  });
};

/**
 * Create a new asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Asset}          asset                           The asset to create
 * @param  {Number[]}       [categories]                    The ids of the categories to which the asset should be associated
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Asset}          callback.asset                  The created asset
 * @api private
 */
var createAsset = function(ctx, asset, categories, callback) {
  // Ensure that all provided categories exist
  CategoriesAPI.getCategoriesById(ctx, categories, function(err, categories) {
    if (err) {
      return callback(err);
    }

    DB.Asset.create(asset).complete(function(err, asset) {
      if (err) {
        log.error({'err': err}, 'Failed to create a new link asset');
        return callback({'code': 500, 'msg': err.message});
      }

      // Add the associated categories to the asset
      asset.setCategories(categories).complete(function(err) {
        if (err) {
          log.error({'err': err}, 'Failed to associate categories to a new link asset');
          return callback({'code': 500, 'msg': err.message});
        }

        // Give the user points for adding a new asset
        ActivitiesAPI.createActivity(ctx.course, ctx.user, 'add_asset', asset.id, CollabosphereConstants.ACTIVITY.OBJECT_TYPES.ASSET, null, function(err) {
          if (err) {
            return callback(err);
          }

          // Retrieve the created asset, including the associated user and
          // associated categories
          getAsset(ctx, asset.id, false, callback);
        });
      });
    });
  });
};

/* FILE UPLOAD */

/**
 * Upload a file to a course in Canvas
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         filePath              The path of the file that should be uploaded
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @api private
 */
var uploadFileToCanvas = function(ctx, filePath, callback) {
  // Step 1: Tell Canvas that we want to upload a file. Canvas will give us some information about
  // where we should ship the file to in step 2
  notifyCanvasOfUpload(ctx, filePath, function(err, uploadInfo) {
    if (err) {
      return callback(err);
    }

    // Step 2: Upload the file to wherever Canvas wants us to upload it. In development this will
    // be your local canvas instance, in production this will probably be an Amazon S3 bucket
    uploadFile(ctx, filePath, uploadInfo, function(err, confirmUrl) {
      if (err) {
        return callback(err);
      }

      // Step 3: Confirm the file was uploaded to Canvas
      confirmFile(ctx, confirmUrl, function(err, file) {
        if (err) {
          return callback(err);
        }

        // Step 4: Hide the file so it doesn't show up in the Files Tool for students
        return hideFile(ctx, file, callback);
      });
    });
  });
};

/**
 * Hide a file. This will ensure that students can't see the uploaded file in the Files tool.
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {Object}         file                  The file information for the uploaded file as described by the Canvas API
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @api private
 */
var hideFile = function(ctx, file, callback) {
  var url = util.format('%s/api/v1/files/%d', getBaseURI(ctx), file.id);
  var opts = {
    'url': url,
    'method': 'PUT',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    },
    'form': {
      'hidden': true
    }
  };
  request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to hide the file');
      return callback({'code': 500, 'msg': 'Failed to hide the file'});
    } else if (response.statusCode !== 200) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to hide the file');
      return callback({'code': 500, 'msg': 'Failed to hide the file'});
    }

    return callback(null, file);
  });
};

/**
 * Confirm that a file has been uploaded to the appropriate file back-end
 *
 * See step 3 at https://canvas.beta.instructure.com/doc/api/file.file_uploads.html
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         confirmUrl            The URL that was returned from the file back-end
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.fileInfo     The file information for the uploaded file as described by the Canvas API
 * @api private
 */
var confirmFile = function(ctx, confirmUrl, callback) {
  var opts = {
    'url': confirmUrl,
    'method': 'POST',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    }
  };
  request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to confirm the file upload');
      return callback({'code': 500, 'msg': 'Failed to confirm the file upload'});
    } else if (response.statusCode !== 200) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to confirm the file upload');
      return callback({'code': 500, 'msg': 'Failed to confirm the file upload'});
    }

    var fileInfo = null;
    try {
      fileInfo = JSON.parse(body);
    } catch (parseErr) {
      log.error({'err': parseErr, 'course': ctx.course.id}, 'Failed to parse Canvas confirm response');
      return callback({'code': 500, 'msg': 'Failed to parse Canvas confirm response'});
    }

    return callback(null, fileInfo);
  });
};

/**
 * Upload the file to the storage back-end. This could be a Canvas instance but could just as well be
 * an Amazon S3 bucket.
 *
 * See step 2 at https://canvas.beta.instructure.com/doc/api/file.file_uploads.html
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         filePath              The path of the file that should be uploaded
 * @param  {Object}         uploadInfo            The signed information that allows us to upload the file
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.fileInfo     The file information for the uploaded file as described by the Canvas API
 * @api private
 */
var uploadFile = function(ctx, filePath, uploadInfo, callback) {
  var opts = {
    'url': uploadInfo.upload_url,
    'method': 'POST',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    }
  };
  var r = request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to upload the file');
      return callback({'code': 500, 'msg': 'Failed to upload the file'});
    } else if (!(response.statusCode === 301 || response.statusCode === 302)) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to upload the file');
      return callback({'code': 500, 'msg': 'Failed to upload the file'});
    }

    var confirmUrl = response.headers.location;
    return callback(null, confirmUrl);
  });

  // We need to add the parameters as multi-part blocks
  var form = r.form();

  // Append all the parameters that we retrieved earlier
  _.each(uploadInfo.upload_params, function(value, key) {
    form.append(key, value);
  });

  // Append the file. Note that the file should always be appended last
  form.append('file', fs.createReadStream(filePath));
};

/**
 * Tell Canvas that we want to upload a file. Canvas will give us some information about where the
 * file should actually be stored.
 *
 * See step 1 at https://canvas.beta.instructure.com/doc/api/file.file_uploads.html
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         filePath              The path for the file that should be uploaded
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.uploadInfo   The signed information that allows us to upload the file
 * @api private
 */
var notifyCanvasOfUpload = function(ctx, filePath, callback) {
  var url = util.format('%s/api/v1/courses/%d/files', getBaseURI(ctx), ctx.course.canvas_course_id);
  var fileInfo = fs.statSync(filePath);
  var contentType = mime.lookup(filePath);

  // We hash the files into folders with an hourly granularity. This avoids generating folders
  // which have to hold lots of files
  var d = new Date();
  var parentFolder = util.format('%d/%d/%d/%d', d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());

  // Prefix the file with an epoch timestamp. This is a crude attempt at avoiding
  // file name collisions
  var filename = util.format('%d_%d_%s', ctx.course.id, d.getTime(), path.basename(filePath));
  var opts = {
    'url': url,
    'method': 'POST',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    },
    'form': {
      // Some information about the file
      'name': filename,
      'filesize': fileInfo.size,
      'content_type': contentType,

      // The folder in which the file should be uploaded
      'parent_folder_path': parentFolder,

      // Overwrite any existing files
      'on_duplicate': 'overwrite'
    }
  };
  request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to notify Canvas of a file upload');
      return callback({'code': 500, 'msg': 'Failed to notify Canvas of a file upload'});
    } else if (response.statusCode !== 200) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to notify Canvas of a file upload');
      return callback({'code': 500, 'msg': 'Failed to notify Canvas of a file upload'});
    }

    var uploadInfo = null;
    try {
      uploadInfo = JSON.parse(body);
    } catch (parseErr) {
      log.error({'err': parseErr, 'course': ctx.course.id}, 'Failed to parse Canvas response');
      return callback({'code': 500, 'msg': 'Failed to parse Canvas response'});
    }

    return callback(null, uploadInfo);
  });
};

/**
 * Get the base URI where a Canvas instance can be reached on.
 * This includes the protocol and hostname.
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @return {String}                               The base URI where the Canvas API can be reached on
 * @api private
 */
var getBaseURI = function(ctx) {
  var canvasProtocol = (ctx.course.canvas.use_https ? 'https' : 'http');
  return util.format('%s://%s', canvasProtocol, ctx.course.canvas.canvas_api_domain);
};

/* COMMENTS */

/**
 * Get a comment.
 * Note that this is a private method that doesn't do any validation
 *
 * @param  {Number}         id                              The id of the comment to retrieve
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.comment                The created comment
 * @param  {User}           callback.comment.user           The user that created the comment
 * @api private
 */
var getComment = function(id, callback) {
  var options = {
    'where': {
      'id': id
    },
    'include': [{
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    }]
  };
  DB.Comment.find(options).complete(function(err, comment) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to retrieve the created comment');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, comment);
  });
};

/**
 * Create a new comment on an asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         assetId                         The id of the asset to which the comment is added
 * @param  {String}         body                            The body of the comment
 * @param  {Number}         [parent]                        The id of the comment to which the comment is a reply
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.comment                The created comment
 * @param  {User}           callback.comment.user           The user that created the comment
 */
var createComment = module.exports.createComment = function(ctx, assetId, body, parent, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'assetId': Joi.number().required(),
    'body': Joi.string().required(),
    'parent': Joi.number().optional()
  });

  var validationResult = Joi.validate({
    'assetId': assetId,
    'body': body,
    'parent': parent
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the asset to which the comment is being added
  getAsset(ctx, assetId, false, function(err, asset) {
    if (err) {
      return callback(err);
    }

    // Check that the comment to which this comment is a reply exists
    if (parent) {
      // Ensure the parent id is a number
      parent = CollabosphereUtil.getNumberParam(parent);
      var parentComment = _.findWhere(asset.toJSON().comments, {'id': parent});
      if (!parentComment) {
        log.error({'err': err, 'parent': parent}, 'Failed to find the comment to which a reply is being made');
        return callback({'code': 400, 'msg': 'Failed to find the comment to which a reply is being made'});
      }
    }

    // Create the link asset in the database
    var comment = {
      'asset_id': assetId,
      'user_id': ctx.user.id,
      'parent_id': parent,
      'body': body
    };

    DB.Comment.create(comment).complete(function(err, comment) {
      if (err) {
        log.error({'err': err}, 'Failed to create a new comment');
        return callback({'code': 500, 'msg': err.message});
      }

      // Increase the comment count
      asset.increment('comment_count').complete(function(err, asset) {

        // Retrieve the created comment, including the associated user
        getComment(comment.id, callback);
      });
    });
  });
};

/**
 * Edit a comment on an asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         assetId                         The id of the asset to which the comment belongs
 * @param  {Number}         id                              The id of the comment that is being edited
 * @param  {String}         body                            The updated comment body
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.comment                The updated comment
 * @param  {User}           callback.comment.user           The user that created the comment
 */
var editComment = module.exports.editComment = function(ctx, assetId, id, body, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'assetId': Joi.number().required(),
    'id': Joi.number().required(),
    'body': Joi.string().required()
  });

  var validationResult = Joi.validate({
    'assetId': assetId,
    'id': id,
    'body': body
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the comment that is being edited
  var options = {
    'where': {
      'id': id,
      'asset_id': assetId
    },
    'include': [DB.Asset]
  };

  DB.Comment.find(options).complete(function(err, comment) {
    if (err) {
      log.error({'err': err, 'id': id, 'assetId': assetId}, 'Failed to retrieve the comment to update');
      return callback({'code': 500, 'msg': err.message});
    } else if (!comment) {
      log.debug({'err': err, 'id': id, 'assetId': assetId}, 'The comment that is being edited could not be found');
      return callback({'code': 404, 'msg': 'The comment that is being edited could not be found'});
    }

    // Verify that the user is allowed to edit the comment. A user is
    // only able to edit a comment when the user manages the course or
    // the comment is their own
    if ((!ctx.user.is_admin || comment.asset.course_id !== ctx.course.id) && comment.user_id !== ctx.user.id) {
      log.error({'assetId': assetId, 'id': id}, 'Unauthorized to edit the comment');
      return callback({'code': 401, 'msg': 'Unauthorized to edit the comment'});
    }

    // Update the comment
    var update = {
      'body': body
    };

    comment.updateAttributes(update).complete(function(err, comment) {
      if (err) {
        log.error({'err': err}, 'Failed to update a comment');
        return callback({'code': 500, 'msg': err.message});
      }

      // Retrieve the updated comment, including the associated user
      getComment(comment.id, callback);
    });
  });
};

/* (DIS)LIKING */

/**
 * Like or dislike an asset
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         assetId                         The id of the asset that is liked or disliked
 * @param  {Boolean}        [like]                          `true` when the asset should be liked, `false` when the asset should be disliked. When `null` is provided, the previous like or dislike will be undone
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 */
var like = module.exports.like = function(ctx, assetId, like, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'assetId': Joi.number().required(),
    'like': Joi.boolean().optional()
  });

  var validationResult = Joi.validate({
    'assetId': assetId,
    'like': like
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the asset that is being liked or disliked
  getAsset(ctx, assetId, false, function(err, asset) {
    if (err) {
      return callback(err);
    }

    // Users are not able to like or dislike their own assets
    if (asset.user_id === ctx.user.id) {
      return callback({'code': 401, 'msg': 'You can not like or dislike your own assets'});
    }

    // Remove the previous like or dislike
    ActivitiesAPI.deleteActivity(ctx.course, ctx.user, ['like', 'dislike'], asset.id, CollabosphereConstants.ACTIVITY.OBJECT_TYPES.ASSET, null, function(err, deletedLike) {
      if (err) {
        return callback(err);
      }

      // Remove the previous get like or get dislike
      ActivitiesAPI.deleteActivity(ctx.course, asset.user, ['get_like', 'get_dislike'], asset.id, CollabosphereConstants.ACTIVITY.OBJECT_TYPES.ASSET, ctx.user, function(err) {
        if (err) {
          return callback(err);
        }

        // Update the like and dislike count on the asset
        updateAssetLikeCount(asset, like, deletedLike, function(err, asset) {
          if (err) {
            return callback(err);
          }

          // If a like or dislike is being undone, no further actions are required
          if (!_.isBoolean(like)) {
            return callback();
          }

          // Add the like / dislike activity
          var type = 'dislike';
          if (like) {
            type = 'like';
          }

          ActivitiesAPI.createActivity(ctx.course, ctx.user, type, asset.id, CollabosphereConstants.ACTIVITY.OBJECT_TYPES.ASSET, null, function(err) {
            if (err) {
              return callback(err);
            }

            // Add the get like / get dislike activity
            type = 'get_dislike';
            if (like) {
              type = 'get_like';
            }

            ActivitiesAPI.createActivity(ctx.course, asset.user, type, asset.id, CollabosphereConstants.ACTIVITY.OBJECT_TYPES.ASSET, ctx.user, function(err) {
              if (err) {
                return callback(err);
              }

              return callback();
            });
          });
        });
      });
    });
  });
};

/**
 * Adjust the cached like and dislike count on an asset after removing a previous like or dislike
 *
 * @param  {Asset}          asset                           The asset for which to update the like and dislike count
 * @param  {Boolean}        like                            `true` when the asset should be liked, `false` when the asset should be disliked. When `null` is provided, the previous like or dislike will be undone
 * @param  {Activity}       deletedLike                     The removed like or dislike activity on the asset
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Asset}          callback.asset                  The updated asset
 * @api private
 */
var updateAssetLikeCount = function(asset, like, deletedLike, callback) {
  var likeDelta = 0;
  var dislikeDelta = 0;
  if (deletedLike) {
    if (deletedLike.type === 'like') {
      likeDelta--;
    } else {
      dislikeDelta--;
    }
  }
  if (like === true) {
    likeDelta++;
  } else if (like === false) {
    dislikeDelta++;
  }

  asset.increment({'likes': likeDelta, 'dislikes': dislikeDelta}).complete(function(err, asset) {
    if (err) {
      log.error({'err': err, 'asset': asset}, 'Failed to update the like and dislike count on an asset');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, asset);
  });
};
