#!/usr/bin/env node

/**
 * Copyright Â©2016. The Regents of the University of California (Regents). All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its documentation
 * for educational, research, and not-for-profit purposes, without fee and without a
 * signed licensing agreement, is hereby granted, provided that the above copyright
 * notice, this paragraph and the following two paragraphs appear in all copies,
 * modifications, and distributions.
 *
 * Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck Avenue,
 * Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, otl@berkeley.edu,
 * http://ipira.berkeley.edu/industry-info for commercial licensing opportunities.
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
 * SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED
 * "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */

var _ = require('lodash');
var crypto = require('crypto');
var fabric = require('fabric').fabric;
var fs = require('fs');
var moment = require('moment-timezone');
var os = require('os');
var path = require('path');
var util = require('util');

var CollabosphereConstants = require('col-core/lib/constants');

var CHART_PADDING = 22;
var CHART_RADIUS = 100;
var DARK_GRAY = '#999';
var LIGHT_GRAY = '#eee';

/**
 * Create a radar chart and export to PNG
 *
 * @api private
 */
var init = function() {
  // Get the chart values from standard in
  getChartValues(function(err, chartValues) {
    if (err) {
      exitWithError(err, 'Could not get chart values from stdin');
    }

    // Export chart as a PNG stream
    generatePng(chartValues, function(err, data) {
      if (err) {
        exitWithError(err, 'Could not generate PNG data');
      }

      // Find or create a path under the Apache document root from which PNG files can be served
      var documentRoot = process.env.DOCUMENT_ROOT;
      if (!documentRoot) {
        exitWithError(null, 'Could not get Apache document root');
      }

      var emailDir = path.join(documentRoot, 'assets', 'email');
      fs.stat(emailDir, function(err, stat) {
        if (err) {
          if (err.code === 'ENOENT') {
            fs.mkdirSync(emailDir);
          } else {
            exitWithError(err, 'Failed to get directory for email assets');
          }
        }

        // Construct filenames using a millisecond timestamp signed with a nonce string
        var date = moment().format('YYYYMMDDHHmmssSSS');
        crypto.randomBytes(4, function(err, buffer) {
          if (err) {
            exitWithError(err, 'Could not get nonce string');
          }

          var nonce = buffer.toString('hex');
          var filename = util.format('radarchart-%s-%s.png', date, nonce);
          var imagePath = path.join(emailDir, filename);

          fs.writeFile(imagePath, data, {'encoding': 'binary'}, function(err) {
            if (err) {
              exitWithError(err, 'Could not write the PNG radar chart to disk');
            }

            // Return the file path to the parent process over stdout
            var returnPath = path.join('/', 'assets', 'email', filename);
            process.stdout.write(returnPath);
            process.exit(0);
          });
        });
      });
    });
  });
};

/**
 * Get chart values from the parent process over standard in
 *
 * @param  {Function}   callback                 Standard callback function
 * @param  {Object}     callback.err             An error that occurred, if any
 * @param  {Object[]}   callback.chartValues     The chart values that were passed in over standard in
 * @api private
 */
var getChartValues = function(callback) {
  // By default, the stdin stream is paused
  process.stdin.resume();
  process.stdin.setEncoding('utf8');

  var data = '';
  process.stdin.on('data', function(chunk) {
    data += chunk.toString();
    // A line break signals the end of the stream
    if (data.indexOf('\n') !== -1) {
      process.stdin.pause();

      // Parse the collected chunks and return the chart values to the caller
      var chartValues = [];
      try {
        chartValues = JSON.parse(data.split('\n')[0]);
      } catch (err) {
        return callback(err);
      };

      return callback(null, chartValues);
    }
  });
};

/**
 * Generate radar chart and export to PNG stream
 *
 * @param  {Object}     chartValues                 The chart values that were passed in over standard in
 * @param  {Object}     chartValues.user            Point set for a single user
 * @param  {Object}     chartValues.courseAverage   Point set for per-course averages
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Buffer}     callback.buff               Buffered PNG data
 * @api private
 */
var generatePng = function(chartValues, callback) {
  initializeChartCanvas(function(canvas, origin) {
    if (!canvas) {
      return callback({'code': 500, 'msg': 'Could not generate canvas for radar chart'});
    }

    // Set scale based on maximum point value
    var maximumPointValue = _.chain(chartValues)
                             .map(_.values)
                             .flatten()
                             .max()
                             .value();
    var scale = CHART_RADIUS / maximumPointValue;

    // Define colors 
    var colorMap = {
      'user': '#4080a0',
      'courseAverage': '#ffc020'
    };

    _.each(chartValues, function(pointSet, key) {
      // Adjust point values to scale
      var scaledPoints = {};
      _.each(CollabosphereConstants.ACTIVITY.POINT_CATEGORIES_FOR_NOTIFICATIONS, function(category) {
        points = pointSet[category] || 0;
        scaledPoints[category] = _.round(scale * points);
      });

      // Draw colored polygon
      canvas.add(new fabric.Polygon(
        [
          {x: origin, y: origin - scaledPoints.pointsFromAssetsUploaded},   // Top corner
          {x: origin + scaledPoints.pointsFromComments, y: origin},         // Right corner
          {x: origin, y: origin + scaledPoints.pointsFromLikes},            // Bottom corner
          {x: origin - scaledPoints.pointsFromWhiteboards, y: origin}       // Left corner
        ], 
        {
          fill: colorMap[key],
          opacity: 0.7
        }
      ));
    });

    // Render the canvas
    canvas.renderAll();

    // Convert the canvas to a PNG file and return the data
    canvas.nodeCanvas.toBuffer(function(err, buff) {
      if (err) {
        return callback(err);
      }

      return callback(null, buff);
    });
  });
};

/**
 * Initialize a Fabric canvas for the radar chart
 *
 * @param  {Function}   callback                 Standard callback function
 * @param  {Canvas}     callback.canvas          The generated Fabric canvas
 * @param  {Number}     callback.origin          The distance in pixels between chart origin and canvas edge
 * @api private
 */
var initializeChartCanvas = function(callback) {
  // Set dimensions
  var chartIncrement = CHART_RADIUS / 5;
  var origin = CHART_RADIUS + CHART_PADDING;
  var canvasSize = origin * 2;

  // Create canvas
  var canvas = fabric.createCanvasForNode(canvasSize, canvasSize);

  // For the sake of speed, don't render the canvas until all elements are added
  canvas.renderOnAddRemove = false;

  canvas.setBackgroundColor('white');

  var addCircle = function(radius, fill) {
    canvas.add(new fabric.Circle({
      left: origin,
      top: origin,
      radius: radius,
      fill: fill,
      originX: 'center',
      originY: 'center',
      stroke: DARK_GRAY,
      strokeWidth: 1
    }));
  };

  var addLine = function(points) {
    canvas.add(new fabric.Line(points, {
      stroke: DARK_GRAY,
      strokeWidth: 1
    }));
  };

  // Draw outer, filled circle
  addCircle(100, LIGHT_GRAY);

  // Draw axis lines
  addLine([origin, 0, origin, canvasSize]);
  addLine([0, origin, canvasSize, origin]);

  // Draw inner circles
  _.times(4, function(index) {
    addCircle((index + 1) * chartIncrement);
  });

  return callback(canvas, origin);
};

/**
 * Log errors and exit
 *
 * @param  {Object}     [err]     The error object to log, if any
 * @param  {String}      msg      Additional message to log
 * @api private
 */
var exitWithError = function(err, msg) {
  if (err) {
    console.error(err);
  }
  console.error(msg);
  process.exit(1);
};

// Initialize the script
init();
