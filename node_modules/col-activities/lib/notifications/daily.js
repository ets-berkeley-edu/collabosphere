/**
 * Copyright ©2015. The Regents of the University of California (Regents). All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its documentation
 * for educational, research, and not-for-profit purposes, without fee and without a
 * signed licensing agreement, is hereby granted, provided that the above copyright
 * notice, this paragraph and the following two paragraphs appear in all copies,
 * modifications, and distributions.
 *
 * Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck Avenue,
 * Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, otl@berkeley.edu,
 * http://ipira.berkeley.edu/industry-info for commercial licensing opportunities.
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
 * SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED
 * "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */

var _ = require('lodash');
var async = require('async');
var EventEmitter = require('events');
var moment = require('moment-timezone');

var ActivitiesAPI = require('col-activities');
var CourseAPI = require('col-course');
var CollabosphereConstants = require('col-core/lib/constants');
var DB = require('col-core/lib/db');
var EmailUtil = require('col-core/lib/email');
var log = require('col-core/lib/logger')('col-activities/notifications');
var UsersAPI = require('col-users');
var UserConstants = require('col-users/lib/constants');


var emitter = module.exports = new EventEmitter();
var EVENT_NAMES = module.exports.EVENT_NAMES = {
  'COURSE_COLLECTED': 'courseCollected',
  'COURSES_COLLECTED': 'coursesCollected'
};

/**
 * Run through all the active courses and send out the daily notification email
 */
var collect = module.exports.collect = function() {
  var start = Date.now();

  // 1. Get all the active courses
  CourseAPI.getCourses(false, function(err, courses) {
    if (err) {
        return log.error({'err': err}, 'Unable to retrieve the courses when sending notifications');
    }

    // 2. Iterate through all the courses
    async.eachSeries(courses, collectCourse, function(err) {
      if (err) {
          return log.error({'err': err}, 'Unable to retrieve the courses when sending notifications');
      }

      log.info('Sent emails for all courses, took %d ms', Date.now() - start);

      emitter.emit(EVENT_NAMES.COURSES_COLLECTED);
    });
  });
};

/**
 * Send out the daily notifications for a specific course.
 *
 * Note that this method is only made publicly available so it can be called from the integration
 * tests. Do not call this method directly.
 *
 * @param  {Course}         course          The course for which to send out the daily notifications
 * @param  {Function}       callback        Standard callback function
 * @api private
 */
var collectCourse = module.exports.collectCourse = function(course, callback) {
  var start = Date.now();

  // 1. Get all the data for this course
  getCourseData(course, function(err, data) {
    if (err) {
      // Don't pass the error up
      emitter.emit(EVENT_NAMES.COURSE_COLLECTED, course);
      return callback();
    }

    // If there's no course data than we can return early
    if (_.isEmpty(data.assets) && _.isEmpty(data.whiteboards)) {
      emitter.emit(EVENT_NAMES.COURSE_COLLECTED, course);
      return callback();
    }

    // 2. Iterate through all the users in this course and send each user an e-mail
    var userIterator = handleUser.bind(null, course, data);
    async.eachSeries(data.users, userIterator, function() {
      log.info('Sent emails for course %d, took %d ms', course.id, Date.now() - start);

      emitter.emit(EVENT_NAMES.COURSE_COLLECTED, course);
      return callback();
    });
  });
};

/**
 * Send notifications for a user in a course.
 *
 * Note that this function won't pass up any errors.
 *
 * @param  {Course}     course        The course for which to send out the daily notifications
 * @param  {Object}     data          The relevant data in the given course
 * @param  {User}       user          The user to notify
 * @param  {Function}   callback      Standard callback function
 * @api private
 */
var handleUser = function(course, data, user, callback) {
  // Ignore users that don't have an email address
  if (!user.canvas_email) {
      return callback();
  }

  // Get all the activities for the user
  var activities = getActivitiesForUser(data, user);

  // If nothing noteworthy happened for this user, then they should not get an email
  if (_.isEmpty(activities)) {
    return callback();
  }

  var subject = getSubject(course, activities, user);

  // The data that's used in the daily email template
  var data = {
    'activities': activities,
    'getSummaryActors': getSummaryActors,
  };
  EmailUtil.sendEmail(subject, user, course, data, 'daily', function(err) {
    // Don't pass errors up as otherwise all the following users would be ignored.
    // The error itself is logged in the sendEmail implementation
    return callback();
  });
};

/**
 * Get the subject for the daily email
 *
 * @param  {Course}                                 course        The course for which to send out the daily notifications
 * @param  {(AssetActivity|WhiteboardActivity)[]}   activities    The set of activities for which to generate an email subject
 * @param  {User}                                   currentUser   The user to whom the email will be sent
 * @return {String}                                               An appropriate email subject
 * @api private
 */
var getSubject = function(course, activities, currentUser) {
  var subject = null;
  if (activities.length === 1) {
    var activity = activities[0];
    if (activity.type === 'asset_comment') {
      var commenters = _.pluck(activity.asset.comments, 'user');
      var summaryActors = getSummaryActors(commenters, currentUser);
      subject = summaryActors + ' commented on your asset ‘' + activity.asset.title + '’';
    } else if (activity.type === 'asset_comment_reply') {
      var commenters = _.pluck(activity.asset.comments, 'user');
      var summaryActors = getSummaryActors(commenters, currentUser);
      var comment = activity.asset.comments[0].body;
      if (comment.length > 40) {
        comment = comment.substring(0, 40) + '...';
      }
      subject = summaryActors + ' replied to your comment ‘' + comment + '’';
    } else if (activity.type === 'whiteboard_chat') {
      var commenters = _.pluck(activity.whiteboard.chats, 'user');
      var summaryActors = getSummaryActors(commenters, currentUser);
      subject = summaryActors + ' commented on your whiteboard ‘' + activity.whiteboard.title + '’';
    }

  // Default to a generic subject title if there's more than 1 activity
  // If the canvas instance for this course has no name, we change the subject slightly as the
  // "from name" already contains "Asset Library and Whiteboards"
  } else {
    subject = 'Today\'s activity in the Asset Library and Whiteboards';
    if (!course.canvas.name) {
      subject = 'Today\'s activity'
    }
  }

  return subject;
};

/* Activity aggregation */

/**
 * Get the relevant activities for a user
 *
 * @param  {Object}       data    The relevant course data
 * @param  {User}         user    The user for which to get the activities
 * @return {Activity[]}           A set of activities for which the user can be notified
 * @api private
 */
var getActivitiesForUser = function(data, user) {
  // This variable will contain all activities that can be emailed to the user
  var emailActivities = [];

  // Asset comments
  _.each(data.assets, function(asset) {
    // Whether the user owns the asset
    var isOwner = asset.users[user.id];

    // All comments made by other users
    var otherComments = _.filter(asset.comments, function(comment) {
      return (comment.user_id !== user.id);
    });

    // All replies made to the current user
    var replies = _.filter(asset.comments, function(comment) {
      return (comment.parent && comment.parent.user_id === user.id);
    });

    // All replies made to the current user by other users
    var otherReplies = _.filter(replies, function(reply) {
      return (reply.user_id !== user.id);
    });

    // If we own the asset, we want all the new comments (that weren't made by ourselves)
    if (isOwner && !_.isEmpty(otherComments)) {
      emailActivities.push(new AssetActivity(asset, 'asset_comment'));
    }

    // If there's a reply on a comment of ours we only want those replies
    else if (!_.isEmpty(replies) && !_.isEmpty(otherReplies)) {
      emailActivities.push(new AssetActivity(asset, 'asset_comment_reply', replies));
    }
  });

  // Add whiteboards that the user is a member of which has new chat messages
  _.each(data.whiteboards, function(whiteboard) {
    var otherChatMessages = _.filter(whiteboard.chats, function(chat) {
      return (chat.user_id !== user.id);
    });

    if (_.find(whiteboard.users, {'id': user.id}) && !_.isEmpty(otherChatMessages)) {
      emailActivities.push(new WhiteboardActivity(whiteboard))
    }
  });

  return _.chain(emailActivities)
    .sortByOrder(['lastActivity'], ['desc'])
    .value();

};

/**
 * An Asset activity
 *
 * @param {Asset}       asset       The asset on which there's some activity
 * @param {String}      type        One of `asset_comment` or `asset_comment_reply`
 * @param {Comment[]}   [replies]   In case it's an `asset_comment_reply` activity, this should be the set of comments that are replies to a comment of the current user
 */
var AssetActivity = function(asset, type, replies) {
  // Take a copy of the asset
  asset = _.extend({}, asset);

  if (type === 'asset_comment_reply') {
    asset.comments = replies;
  }

  // Flatten the comments
  var comments = replies || asset.comments;
  var commentsById = {};
  _.each(comments, function(comment) {
    commentsById[comment.id] = _.extend({}, comment);
    if (comment.parent) {
      commentsById[comment.parent.id] = _.extend({}, comment.parent);
    }
  });
  comments = _.values(commentsById);

  // Order the comments from newest to oldest
  comments.sort(function(a, b) {
    return b.id - a.id;
  });

  // Extract the top-level comments
  var commentsTree = [];
  for (var i = 0; i < comments.length; i++) {
    var comment = comments[i];
    if (!comment.parent_id) {
      comment.level = 0;
      commentsTree.unshift(comment);

      // Find all replies for the current comment
      for (var r = 0; r < comments.length; r++) {
        var reply = comments[r];
        if (reply.parent_id === comment.id) {
          reply.level = 1;
          commentsTree.splice(1, 0, reply);
        }
      }
    }
  }

  asset.comments = commentsTree;

  var that = {
    'type':  type,
    'lastActivity': comments[0].created_at,
    'asset': asset
  };

  return that;
};

/**
 * A whiteboard activity
 *
 * @param {Whiteboard}    whiteboard    The whiteboard for which there's an activity
 */
var WhiteboardActivity = function(whiteboard) {
  var that = {
    'type': 'whiteboard_chat',
    'lastActivity': _.chain(whiteboard.chats).sortBy('created_at').last().value().created_at,
    'whiteboard': whiteboard
  };

  return that;
};

/**
 * Given a set of users and the current user, get a string representation for those users.
 *
 * For example,
 *   - [Jack]                   results in: "Jack"
 *   - [Jack, Jill]             results in: "Jack and Jill"
 *   - [Jack, Jill, John]       results in: "Jack, Jill and 1 other"
 *   - [Jack, Jill, John, Dave] results in: "Jack, Jill and 2 others"
 *
 * @param  {User[]}   users         A set of users
 * @param  {User}     currentUser   The current user
 * @return {String}                 A string representation of the set of users
 * @api private
 */
var getSummaryActors = function(users, currentUser) {
  var actors = _.chain(users)
    .uniq('id')
    .filter(function(user) {
      return (user.id !== currentUser.id);
    })
    .value()

  if (actors.length === 1) {
    return actors[0].canvas_full_name
  } else if (actors.length === 2) {
    return actors[0].canvas_full_name + ' and ' + actors[1].canvas_full_name
  } else if (actors.length === 3) {
    return actors[0].canvas_full_name + ', ' + actors[1].canvas_full_name + ' and 1 other'
  } else {
    var nOthers = actors.length - 2;
    return actors[0].canvas_full_name + ', ' + actors[1].canvas_full_name + ' and ' + nOthers + ' others';
  }
};


/* Data retrieval */


/**
 * Get the course data that had any activity in the last day. This will include:
 *  - assets that were commented on
 *  - assets were a comment was placed on a reply
 *  - whiteboards that received chat messages
 *
 * @param  {Context}    course                        The course for which to get the course data
 * @param  {Function}   callback                      Standard callback
 * @param  {Object}     callback.err                  An error object, if any
 * @param  {Object}     callback.data                 The relevant daily data in the course
 * @param  {Object}     callback.data.users           All the users in the course (including those that weren't active)
 * @param  {Object}     callback.data.assets          Assets with recent comments
 * @param  {Object}     callback.data.whiteboards     Whiteboards with recent chat messages
 * @api private
 */
var getCourseData = function(course, callback) {
  var ctx = {
    'course': course,

    // Fake an admin user. At this point we can't reliably retrieve an admin from
    // the database as there might not be any yet
    'user': {
      'is_admin': true
    }
  };

  // 1. Get all the users in this course. We need to retrieve all users as we might need to display
  // a user's name in the email even if they weren't active. (For example, the parent comment of a
  // recent reply)
  var enrollmentStates = _.values(CollabosphereConstants.ENROLLMENT_STATE);
  UsersAPI.getAllUsers(ctx, enrollmentStates, function(err, users) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to retrieve the users for a course');
      return callback({'code': 500, 'msg': 'Failed to retrieve the users for a course'});
    }

    // Index the users by their id. This allows for quicker lookups later on
    users = _.chain(users)
      .map(function(user) {
        return user.toJSON();
      })
      .indexBy('id')
      .value();

    // 2. Get all the assets and comments that are involved in the activities
    getCourseAssetData(ctx, users, function(err, assets) {
      if (err) {
        return callback(err);
      }

      // 3. Get the whiteboards
      getCourseWhiteboardData(ctx, users, function(err, whiteboards) {
        if (err) {
          return callback(err);
        }

        var data = {
          'users': users,
          'assets': assets,
          'whiteboards': whiteboards
        };
        return callback(null, data);
      });
    });
  });

};

/**
 * Get the assets which were commented on recently
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current course
 * @param  {Object}     users               The users in the course (keyed by their user id)
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Object}     callback.assets     Assets that were recently commented on
 * @api private
 */
var getCourseAssetData = function(ctx, users, callback) {
  // Get the assets which have comments in the last 24 hours (including their parents if they have any)
  var yesterday = get24HoursAgoTimestamp();
  var options = {
    'where': {
      'course_id': ctx.course.id
    },
    'include': [
      // Ideally, we'd just get the IDs and look up the objects in the `users` array ourselves
      // to reduce data serialization. Unfortunately, Sequelize doesn't like this very much,
      // so we simple get the basic user profiles
      {'model': DB.User, 'as': 'users', 'required': true, 'attributes': UserConstants.BASIC_USER_FIELDS},

      // The comments
      {'model': DB.Comment, 'required': true, 'where': {'created_at': {'gt': yesterday}}, 'include': [
        {'model': DB.Comment, 'required': false, 'as': 'parent'}
      ]}
    ],
    'limit': null,
    'subQuery': false
  };
  DB.Asset.findAll(options).complete(function(err, assets) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Unable to get the assets for a course');
      return callback(err);
    }

    assets = _.map(assets, function(asset) {
      asset = asset.toJSON();

      // Index the asset owners by their ID for quick lookups
      asset.users = _.indexBy(asset.users, 'id');

      // Add the commenters their user object
      asset.comments = _.map(asset.comments, function(comment) {
        comment = comment.toJSON();

        comment.user = users[comment.user_id];
        if (comment.parent) {
          comment.parent.user = users[comment.parent.user_id];
        }

        return comment;
      });

      return asset;
    });

    return callback(null, assets);
  });
};

/**
 * Get the assets with recent chat messages
 *
 * @param  {Context}    ctx                     Standard context containing the current user and the current course
 * @param  {Object}     users                   The users in the course (keyed by their user id)
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {Object}     callback.whiteboards    Whiteboards with recent chat messages
 * @api private
 */
var getCourseWhiteboardData = function(ctx, users, callback) {
  // Get all the whiteboards that have chat messages in the past 24 hours
  var yesterday = get24HoursAgoTimestamp();
  var queryOptions = {
    'where': {
      'course_id': ctx.course.id
    },
    'include': [
      {
        'model': DB.User
      },
      {
        'model': DB.Chat,
        'where': {
          'created_at': {
            'gt': yesterday
          }
        }
      }
    ]
  };
  DB.Whiteboard.findAll(queryOptions).complete(function(err, whiteboards) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Unable to get the whiteboards for a course');
      return callback(err);
    }

    // Add the user object of the chatter to each chat message
    whiteboards = _.map(whiteboards, function(whiteboard) {
      whiteboard = whiteboard.toJSON();

      whiteboard.chats = _.chain(whiteboard.chats)
        .map(function(chat) {
          chat.user = users[chat.user_id];
          return chat;
        })
        .sortBy('id')
        .value();

      return whiteboard;
    });

    return callback(null, whiteboards || []);
  });
};

/**
 * Get a formatted timestamp for 24 hours ago
 *
 * @return {String}   A formatted timestamp that is suitable to use when querying through Sequelize
 */
var get24HoursAgoTimestamp = function() {
  return moment(new Date(Date.now() - 24 * 60 * 60 * 1000)).format('YYYY-MM-DD HH:mm:ss');
};
