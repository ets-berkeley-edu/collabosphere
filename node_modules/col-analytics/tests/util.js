/**
 * Copyright Â©2017. The Regents of the University of California (Regents). All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its documentation
 * for educational, research, and not-for-profit purposes, without fee and without a
 * signed licensing agreement, is hereby granted, provided that the above copyright
 * notice, this paragraph and the following two paragraphs appear in all copies,
 * modifications, and distributions.
 *
 * Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck Avenue,
 * Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, otl@berkeley.edu,
 * http://ipira.berkeley.edu/industry-info for commercial licensing opportunities.
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
 * SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED
 * "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */

var _ = require('lodash');
var assert = require('assert');
var config = require('config');
var url = require('url');

var DB = require('col-core/lib/db');
var MockedRequest = require('col-tests/lib/model').MockedRequest;

var caliperUrl = url.parse(config.get('analytics.caliper.url'));

/**
 * Expect to receive a Caliper event matching provided data
 *
 * @param  {User}               user                          The SuiteC user associated with the event
 * @param  {Course}             course                        The SuiteC course associated with the event
 * @param  {Object}             [opts]                        Optional parameters to verify
 * @return {void}
 * @throws {AssertionError}                                   Error thrown when an assertion failed
 */
var expectCaliperEvent = module.exports.expectCaliperEvent = function(user, course, opts) {
  var mockedRequest = new MockedRequest('POST', caliperUrl.pathname, 201, null, null, null, function(req) {
    assertCaliperPayload(req.body, user, course, opts);
  });
  global.tests.caliper.appServer.expect(mockedRequest);

  // The asynchronous nature of Caliper events makes them difficult to test in isolation. During multi-test runs, it's possible
  // that events generated by a previous test will not hit the listener until the next test is underway. Having the listener
  // simply ignore all unexpected events isn't a great solution, because it will cause legitimate failures to be swallowed, and
  // instead of an informative error report we'll get a mystery timeout (see onExpectationResult below).
  //
  // However, we can take advantage of the fact that user ids are random and change from test to test. Telling the
  // listener to allow all events not matching the current user id will cause them to pass without comment, reserving scrunity
  // for events matching the user in question.
  //
  // Note that under this solution, expectations can't be set for multiple users in the same test case.
  if (user) {
    allowCaliperEvents(function(event) {
      return (event.actor && event.actor.id && !event.actor.id.endsWith(user.id));
    });
  }
};

/**
 * Allow Caliper events for which a supplied function returns true. Since integration tests tend to generate many more events
 * than we're actually interested in testing, it helps to skip expectation matching on those that don't interest us.
 *
 * @param  {Function}           eventTest                     A function returning true if the event should be allowed, false otherwise
 * @return {void}
 */
var allowCaliperEvents = module.exports.allowCaliperEvents = function(eventTest) {
  global.tests.caliper.appServer.allow(function(req) {
    if (req && req.body && req.body.data && req.body.data[0] && eventTest(req.body.data[0])) {
      return true;
    } else {
      return false;
    }
  });
};

/**
 * Shorthand to allow (i.e. ignore and let pass) any Caliper events matching supplied actions.
 *
 * @param  {String[]}           actions                     Array of string terms for allowed action
 * @return {void}
 */
var allowCaliperActions = module.exports.allowCaliperActions = function(actions) {
  allowCaliperEvents(function(event) {
    return _.includes(actions, event.action);
  });
};

/**
 * Execute a supplied callback when all expectations are satisfied or an expectation fails. This forces the test to
 * wait while expectations remains unsatisfied; if an expected event is never received, the callback will never execute
 * and the test will time out.
 *
 * @param  {Function}           callback                     Callback to be executed
 * @return {void}
 */
var onExpectationResult = module.exports.onExpectationResult = function(callback) {
  global.tests.caliper.appServer.onExpectationResult(_.once(callback));
};

/**
 * Assert that a Caliper envelope containing a single event has expected properties
 *
 * @param  {Object}             envelope                      The Caliper envelope to be checked
 * @param  {User}               user                          The SuiteC user associated with the event
 * @param  {Course}             course                        The SuiteC course associated with the event
 * @param  {Object}             [opts]                        Optional parameters to verify
 * @return {void}
 * @throws {AssertionError}                                   Error thrown when an assertion failed
 */
var assertCaliperPayload = module.exports.assertCaliperPayload = function(envelope, user, course, opts) {
  opts = opts || {};

  assert.ok(envelope);
  assert.ok(envelope.sensor);
  assert.ok(envelope.sendTime);

  assert.strictEqual(envelope.dataVersion, 'http://purl.imsglobal.org/ctx/caliper/v1p1');
  assert.strictEqual(envelope.data.length, 1);

  assertCaliperEvent(envelope.data[0], user, course, opts);
};

/**
 * Assert that a Caliper event has expected properties
 *
 * @param  {Object}             event                         The event object to assert the properties for
 * @param  {User}               user                          The SuiteC user associated with the event
 * @param  {Course}             course                        The SuiteC course associated with the event
 * @param  {Object}             [opts]                        Optional parameters to verify
 * @return {void}
 * @throws {AssertionError}                                   Error thrown when an assertion failed
 */
var assertCaliperEvent = function(event, user, course, opts) {
  assert.strictEqual(event['@context'], 'http://purl.imsglobal.org/ctx/caliper/v1p1');
  assert.ok(event.id.startsWith('urn:uuid:'));
  assert.ok(event.eventTime);

  if (opts.type) {
    assert.strictEqual(opts.type, event.type);
  } else {
    assert.ok(event.type);
  }

  if (opts.action) {
    assert.strictEqual(opts.action, event.action);
  } else {
    assert.ok(event.action);
  }

  if (_.isString(event.object)) {
    if (opts.object) {
      assert.strictEqual(event.object, opts.object);
    }
  } else {
    assert.ok(event.object.id);
    if (opts.object) {
      _.forOwn(opts.object, function(value, key) {
        if (key === 'extensions') {
          _.forOwn(value, function(extensionValue, extensionKey) {
            assert.deepEqual(extensionValue, event.object.extensions[extensionKey]);
          });
        } else if (key === 'creators') {
          // Creator order is not guaranteed; sort before asserting equality.
          assert.deepEqual(_.sortBy(value, 'name'), _.sortBy(event.object[key], 'name'));
        } else {
          assert.deepEqual(value, event.object[key]);
        }
      });
    }
  }

  if (user) {
    assert.ok(event.actor.id.endsWith(user.id));
    assert.strictEqual(event.actor.type, 'Person');
    assert.strictEqual(event.actor.name, user.fullName);
  }

  if (course) {
    assert.ok(event.group.id.endsWith(course.id));
    assert.strictEqual(event.group.type, 'Organization');
    assert.strictEqual(event.group.name, course.title);
  }

  if (user && course) {
    assert.ok(event.membership.member.endsWith(user.id));
    assert.ok(event.membership.organization.endsWith(course.id));
    assert.strictEqual(event.membership.type, 'Membership');
  }

  if (opts.generated) {
    _.forOwn(opts.generated, function(value, key) {
      assert.deepEqual(value, event.generated[key]);
    });
  }

  if (opts.referrer) {
    assert.deepEqual(opts.referrer, event.referrer);
  }

  if (opts.extensions) {
    _.forOwn(opts.extensions, function(value, key) {
      assert.deepEqual(value, event.extensions[key]);
    });
  }
};

/**
 * Get most recent Event per course, user
 *
 * @param  {Course}         course                     The course associated with the event
 * @param  {User}           user                       The user associated with the event
 * @param  {Function}       callback                   Callback function
 * @param  {Object}         [callback.err]             Error, if any
 * @param  {Number}         [callback.event]           Matching event, if any
 * @return {void}
 */
var getMostRecentEvent = module.exports.getMostRecentEvent = function(course, user, callback) {
  var opts = {
    limit: 1,
    where: {
      canvas_user_id: user.id,
      canvas_course_id: course.id
    },
    order: 'created_at DESC'
  };
  DB.Event.findAll(opts).complete(function(err, events) {
    return callback(err, _.size(events) ? events[0] : null);
  });
};

/**
 * Assert that Event has expected properties
 *
 * @param  {Object}         event             The actual event received in test
 * @param  {String}         eventName         Human readable name of event
 * @param  {User}           user              The user associated with the event
 * @param  {Course}         course            The course associated with the event
 * @param  {Object}         ids               Expected values for activityId, assetId, commentId, etc.
 * @param  {Function}       callback          Standard callback function
 * @return {Object}                           Callback return
 * @throws {AssertionError}                   Error thrown when an assertion failed
 */
var assertEvent = module.exports.assertEvent = function(event, eventName, user, course, ids, callback) {
  assert.ok(event);
  assert.ok(event.canvas_domain);
  assert.ok(event.event_metadata);
  assert.strictEqual(event.canvas_user_id, user.id);

  var metadata = event.event_metadata;

  // Verify that property blacklisting is in effect
  var toString = JSON.stringify(metadata);
  assert.equal(toString.indexOf('_length'), -1);
  assert.equal(toString.indexOf('_url'), -1);

  if (ids) {
    if (ids.activityId) {
      assert.equal(event.activity_id, ids.activityId);
    }
    if (ids.assetId) {
      assert.equal(event.asset_id, ids.assetId);
      assert.ok(metadata.asset_title);
      assert.ok(metadata.asset_updated_at);
    }
    if (ids.commentId) {
      assert.equal(event.comment_id, ids.commentId);
      assert.ok(event.asset_id);
      assert.ok(metadata.asset_title);
      assert.ok(metadata.comment_body);
      assert.ok(metadata.comment_updated_at);
    }
    if (ids.whiteboardId) {
      assert.equal(event.whiteboard_id, ids.whiteboardId);
      assert.ok(metadata.whiteboard_title);
      assert.ok(metadata.whiteboard_updated_at);
    }
    if (ids.whiteboardElementUid) {
      assert.equal(event.whiteboard_element_uid, ids.whiteboardElementUid);
      assert.equal(event.whiteboard_id, ids.whiteboardId);
      assert.ok(metadata.whiteboard_title);
      assert.ok(metadata.whiteboard_updated_at);
    }
  }
  return callback();
};

/**
 * Assert that event can be tracked via API
 *
 * @param  {RestClient}         client                        The REST client to make the request with
 * @param  {Course}             course                        Course per context
 * @param  {String}             eventName                     Type of user activity
 * @param  {Object}             [metadata]                    IDs associated with user activity on SuiteC
 * @param  {Number}             [activityId]                  Object id
 * @param  {Number}             [assetId]                     Object id
 * @param  {Number}             [commentId]                   Object id
 * @param  {Number}             [whiteboardId]                Object id
 * @param  {Number}             [whiteboardElementUid]        Object id
 * @param  {Function}           callback                      Standard callback function
 * @param  {Object}             [callback.err]                Error, if any
 * @return {Object}                                           Callback return
 */
var assertTrackAPI = module.exports.assertTrackAPI = function(
  client,
  course,
  eventName,
  metadata,
  activityId,
  assetId,
  commentId,
  whiteboardId,
  whiteboardElementUid,
  callback
) {
  // Too much of a good thing
  client.events.track(course, eventName, metadata, activityId, assetId, commentId, whiteboardId, whiteboardElementUid, function(err) {
    return callback(err);
  });
};
