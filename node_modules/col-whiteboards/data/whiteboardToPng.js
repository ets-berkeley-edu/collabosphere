#!/usr/bin/env node

/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var fabric = require('fabric').fabric;

// The amount of padding (in pixels) that should be added to whiteboards that get exported to PNG
var WHITEBOARD_PADDING = 10;

/**
 * Export a whiteboard as a PNG
 *
 * @api private
 */
var init = function() {
  // Get the whiteboard elements from standard in
  getWhiteboardElements(function(whiteboardElements) {

    // Create a PNG stream for these elements
    generatePng(whiteboardElements, function(err, data) {
      if (err) {
        console.error(err);
        process.exit(2);
      }

      // Write the PNG data out over standard out and exit the process
      process.stdout.write(data);
      process.exit(0);
    });
  });
};

/**
 * Get the whiteboard elements that are passed in over standard in
 *
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object[]}   callback.whiteboardElements     The whiteboard elements that were passed in over standard in
 * @api private
 */
var getWhiteboardElements = function(callback) {
  // By default, the standard in stream is paused. Resume it and collect all the chunks
  process.stdin.resume();
  process.stdin.setEncoding('utf8');

  var data = '';
  process.stdin.on('data', function(chunk) {
    data += chunk.toString();
    if (data.indexOf('\n') !== -1) {
      // Although we only expect 1 line-break to be passed in, ensure we don't end up calling the
      // callback multiple times
      process.stdin.pause();

      // Parse the collected chunks and return the whiteboard elements to the caller
      var whiteboardElements = [];
      try {
        whiteboardElements = JSON.parse(data.split('\n')[0]);
      } catch (err) {
        console.error(err);
        console.error('Could not parse the input JSON');
        process.exit(1);
      };

      return callback(whiteboardElements);
    }
  });
};

/**
 * Generate a PNG version of a canvas that holds the whiteboard elements
 *
 * @param  {Object[]}     whiteboardElements      The elements on the canvas
 * @param  {Function}     callback                Standard callback function
 * @param  {Object}       callback.err            An error that occurred, if any
 * @param  {Buffer}       callback.data           The PNG version of the elements on the canvas
 * @api private
 */
var generatePng = function(whiteboardElements, callback) {
  // Variables that will keep track of what the outer corners of the elements in the canvas are
  var left = Number.MAX_VALUE;
  var top = Number.MAX_VALUE;
  var right = Number.MIN_VALUE;
  var bottom = Number.MIN_VALUE;

  // A variable that will keep track of all the deserialized elements in the whiteboard
  var deserializedElements = [];

  var render = _.after(whiteboardElements.length, function() {
    // At this point we've figured out what the left-most and right-most element is. By subtracting
    // their X-coordinates we get the desired width of the canvas. The height can be calculated in
    // a similar way by using the Y-coordinates
    var width = right - left;
    var height = bottom - top;

    // Add a bit of padding so elements don't stick to the side
    width += (2 * WHITEBOARD_PADDING);
    height += (2 * WHITEBOARD_PADDING);

    // Create a canvas and pan it to the top-left corner
    var canvas = createCanvas(width, height);
    var pt = new fabric.Point(left - WHITEBOARD_PADDING, top - WHITEBOARD_PADDING);
    canvas.absolutePan(pt);

    // Don't render each element when it's added, rather render the entire Canvas once all elements
    // have been added. This is significantly faster
    canvas.renderOnAddRemove = false;

    // Add each element to the canvas
    _.each(deserializedElements, function(deserializedElement) {
      canvas.add(deserializedElement);
    });

    // Ensure each element is placed at the right index. This cannot happen in the previous loop as all
    // elements have to be part of the canvas before their index property can be adjusted
    _.each(deserializedElements, function(deserializedElement) {
      try {
        deserializedElement.moveTo(deserializedElement.get('index'));
      } catch (err) {
        // Strangely enough, when trying to move an image of an unsupported type, Canvas throws an
        // "Image given has not completed loading" error. See https://github.com/Automattic/node-canvas/issues/289
        // for more information. In that case we take the image back out
        if (err.message === 'Image given has not completed loading') {
          console.error('The uploaded image is not supported by node-canvas');
          var element = getCanvasElement(canvas, deserializedElement.uid);
          canvas.remove(element);
        } else {
          console.error('Error when trying to move element');
          console.error(err);
        }
      }
    });

    // Render the canvas
    canvas.renderAll();

    // Convert the canvas to a PNG file and return the data
    return canvas.nodeCanvas.toBuffer(callback);
  });

  _.each(whiteboardElements, function(whiteboardElement) {
    // Canvas doesn't seem to deal terribly well with text elements that specify a prioritized list
    // of font family names. It seems that the only way to render custom fonts is to only specify one
    if (whiteboardElement.fontFamily) {
      whiteboardElement.fontFamily = 'HelveticaNeue-Light';
    }

    // Deserialize the element, get its boundary and check how large
    // the canvas should be to display the element entirely
    deserializeElement(whiteboardElement, function(deserializedElement) {
      var bound = deserializedElement.getBoundingRect();

      left = Math.min(left, bound.left);
      top = Math.min(top, bound.top);
      right = Math.max(right, bound.left + bound.width);
      bottom = Math.max(bottom, bound.top + bound.height);

      // Retain a reference to the deserialized elements. This allows for moving each element
      // to the right index once all alements have been added to the canvas
      deserializedElements.push(deserializedElement);

      render();
    });
  });
};

/* Fabric utilities */

// Ensure that the horizontal and vertical origins of objects are set to center
fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';

/**
 * Create a Fabric.JS canvas instance. The `HelveticaNeue-Light` font will be pre-loaded
 *
 * @param  {Number}     width     The width of the desired Canvas instance
 * @param  {Number}     height    The height of the desired Canvas instance
 * @return {Canvas}               A Fabric.JS canvas instance
 * @api private
 */
var createCanvas = function(width, height) {
  // Create a canvas of the desired dimensions
  var canvas = fabric.createCanvasForNode(width, height);

  // Add the Helvetica Neueu font so text elements can be rendered correctly
  var fontPath = __dirname + '/HelveticaNeueuLight.ttf';
  var font = new canvas.Font('HelveticaNeue-Light', fontPath);
  canvas.contextContainer.addFont(font);
  return canvas;
};

/**
 * Convert a serialized Fabric.js canvas element to a proper Fabric.js canvas element
 *
 * @param  {Object}         element           The serialized Fabric.js canvas element to deserialize
 * @param  {Function}       callback          Standard callback function
 * @param  {Object}         callback.element  The deserialized Fabric.js canvas element
 * @api private
 */
var deserializeElement = function(element, callback) {
  // Extract the type from the serialized element
  var type = fabric.util.string.camelize(fabric.util.string.capitalize(element.type));
  if (fabric[type].async) {
    fabric[type].fromObject(element, callback);
  } else {
    return callback(fabric[type].fromObject(element));
  }
};

/**
 * Get a Fabric.js canvas element based on its unique id
 *
 * @param  {Object}         canvas            The Fabric.js canvas instance to retrieve the element from
 * @param  {String}         uid               The unique id of the Fabric.js canvas element to retrieve
 * @return {Object}                           The retrieved Fabric.js canvas element
 */
var getCanvasElement = function(canvas, uid) {
  var elements = canvas.getObjects();
  for (var i = 0; i < elements.length; i++) {
    if (elements[i].get('uid') === uid) {
      return elements[i];
    }
  }
  return null;
};

// Initialize the script
init();
